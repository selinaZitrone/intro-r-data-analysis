---
subtitle: "Introduction to R - Day "
author: "Selina Baldauf"
institute: "Freie Universit√§t Berlin - Theoretical Ecology"
date: "2021-06-15"
output:
  xaringan::moon_reader:
    seal: false
    css: [default, css/new_slides.css]
    nature:
      highlightStyle: github
      highlightLines: true
      ratio: 16:9
      countIncrementalSlides: false
      beforeInit: "macros.js"
      slideNumberFormat:  |
        <div class="progress-bar-container">
          <div class="progress-bar" style="width: calc(%current% / %total% * 100%);">
          </div>
        </div>
params:
  title: "Data frames and tibbles: tables in R"
  day: "1"
  bg_image: ""
  bg_image_scale: "50%"
  bg_position: "70% 70%"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = FALSE)
library(fontawesome)
library(tibble)
```

```{r child="title_slide.Rmd"}

```

---
# Data frames

The built-in data structure for tables in R is a `data frame`.

.pull-left[

- vectors in R can't represent a table with data that is connected

> Data frames are one of the **biggest and most important ideas** in R, and one of the things that make R different from other programming languages.<br>.small[(Wickham, [Advanced R](https://adv-r.hadley.nz/vectors-chap.html#tibble))]

]

.pull-right[

```{r echo=FALSE}
# list of 10 biggest cities in Europe
cities <- c("Istanbul", "Moscow", "London", "Saint Petersburg", "Berlin", "Madrid", "Kyiv", "Rome", "Bucharest", "Paris")
population <- c(15.1e6, 12.5e6, 9e6, 5.4e6, 3.8e6, 3.2e6, 3e6, 2.8e6, 2.2e6, 2.1e6)
area_km2 <- c(2576, 2561, 1572, 1439,891,604, 839, 1285, 228, 105 )

data.frame(cities = cities,
           population = population,
           area_km2 = area_km2) |> 
  knitr::kable()
```

]

---
# Data frames

A data frame is a **named list of vectors** of the same length.

--

.pull-left[

#### Basic properties of a data frame

- every <b>.col1[column is a vector]</b>
- columns have a <b>.col2[header]</b>
  - this is the <b>.col2[name]</b> of the vector in the list
- within one column, all values are of the <b>.col3[same data type]</b>
- every column has the same length

]
.pull-right[
.center[

![:scale 70%](img/day1/data_frame_specs_all.png) ]
]

---
# Data frames

Data frames are created with the function `data.frame()`:

.pull-left[

```{r eval=FALSE}
cities <- c(
  "Istanbul", "Moscow", "London", 
  "Saint Petersburg", "Berlin","Madrid",
  "Kyiv", "Rome", "Bucharest","Paris")

population <- c(
  15.1e6, 12.5e6, 9e6, 5.4e6, 3.8e6,
  3.2e6, 3e6, 2.8e6, 2.2e6, 2.1e6)

area_km2 <- c(2576, 2561, 1572, 1439, 
  891, 604, 839, 1285, 228, 105)

```
```{r eval=FALSE}
data.frame( #<<
  cities = cities, #<<
  population = population, #<<
  area_km2 = area_km2#<<
  )#<<
```
]

--

.pull-right[
```{r echo=FALSE}
# list of 10 biggest cities in Europe
cities <- c("Istanbul", "Moscow", "London", "Saint Petersburg", "Berlin", "Madrid", "Kyiv", "Rome", "Bucharest", "Paris")
population <- c(15.1e6, 12.5e6, 9e6, 5.4e6, 3.8e6, 3.2e6, 3e6, 2.8e6, 2.2e6, 2.1e6)
area_km2 <- c(2576, 2561, 1572, 1439, 891, 604, 839, 1285, 228, 105)

data.frame(
  cities = cities,
  population = population,
  area_km2 = area_km2
)
```

]

---
# Tibbles

Tibbles are 

>a **modern reimagining of the data frame**. Tibbles are designed to be (as much as possible) **drop-in replacements** for data frames. <br>.small[(Wickham, [Advanced R](https://adv-r.hadley.nz/vectors-chap.html#tibble)) ]

--

Have a look at [this book chapter](https://adv-r.hadley.nz/vectors-chap.html#tibble) for a full list of the differences between data frames and tibbles and the advantages of using tibbles.

--

.pull-left[
- tibbles have the same basic properties as data frames (named list of vectors)

- everything that you can do with data frames, you can do with tibbles

]

.pull-right[
.center[
![](img/day1/data_frame_tibble.png)]
]

---
# Tibbles

Tibbles are a available from the `tibble` package.

--

.pull-left[

Before we use tibbles, we need to install the package once using the function `install.packages`:

```{r eval=FALSE}
# This has do be once
install.packages("tibble")
```

Then, we need to load and attach the package to our current R session using `library`:

```{r eval=FALSE}
# This has to be done every time R restarts
# Put it at the beginning of a script
library(tibble)
```
]

.pull-right[.center[![:scale 50%](img/hex-stickers/tibble.png)]]

---
# Tibbles

Create a tibble using the `tibble()` function:

--

.pull-left[
```{r eval=FALSE}
library(tibble) #<<

tibble( #<<
  cities = cities,
  population = population,
  area_km2 = area_km2
) #<<
```
]
.pull-right[
```{r echo=FALSE}
cities_tbl<- tibble(
  cities = cities,
  population = population,
  area_km2 = area_km2
)
cities_tbl
```
]

--

.small[Note: If you want to use a function from a package you can attach it using `library(package)` or you can use `package::function` to tell R where a function is from (e.g. `tibble::tibble()`). I will sometimes do this to clearly distinguish between base R and package functions.]

---
# Tibbles

Convert a data frame to a tibble using `as_tibble()`:

```{r eval=FALSE}
cities_df <- data.frame(
  cities = cities,
  population = population,
  area_km2 = area_km2
)

cities_tbl <- as_tibble(cities_df) #<<
```

---
# Exploring tibbles

Look at the structure of an object using `str()`:

```{r}
str(cities_tbl)
```
--
- This function shows you:
  - data type of object (`tbl_df/tbl/data.frame`)
  - extent of the data (10 rows times 3 columns)
  - column names and data types

- This function works for every R object and is very useful if code doesn't work and you don't know why
---
# Exploring tibbles

How many rows?

```{r}
nrow(cities_tbl)
```
--
How many columns?

```{r}
ncol(cities_tbl)
```
--
What are the column headers?

```{r}
names(cities_tbl)
```

---
# Exploring tibbles

Look at the entire table in a separate window with `view()`:

```{r eval=FALSE}
tibble::view(cities_tbl)
```

--

Get a quick summary of all columns:

```{r}
summary(cities_tbl)
```

---
# Indexing tibbles

Indexing tibbles works similar to indexing vectors but with two dimensions instead of 1:<br>

<b>.center[ tibble [ .col1[row_index], .col2[col_index or col_name] ]]</b>

--

- Missing row_index or col_index means *all rows* or *all columns* respectively.

--

- Indexing a tibble using `[]` always returns another tibble.

---
# Indexing tibbles

```{r}
# First row and first column
cities_tbl[1, 1]
```

--

This is the same as 

```{r eval=FALSE}
cities_tbl[1, "cities"]
```

---
# Indexing tibbles: rows

What happens here?

```{r}
cities_tbl[(nrow(cities_tbl) - 2):nrow(cities_tbl), ]
```

--
This was the same as writing:

```{r eval=FALSE}
cities_tbl[8:10, ] # return rows 8 to 10, all columns
```


---
# Indexing tibbles: columns

```{r eval=FALSE}
# rows 1 & 5, first two columns:
cities_tbl[c(1, 5) ,1:2]
```

This is the same as

```{r eval=FALSE}
# same as 
cities_tbl[c(1, 5),
           c("cities", "population")]
```

---
# Indexing tibbles: columns 

To index only columns (all rows), you can use `[]` without comma:

```{r eval=FALSE}
cities_tbl[1:2]
# or
cities_tbl[c("cities", "population")]
```

```{r echo=FALSE}
print(cities_tbl[ ,c("cities", "population")], n=3)
```

--

This is the same as

```{r eval=FALSE}
cities_tbl[1:2, ]
# or
cities_tbl[c("cities", "population"), ]
```

---
# Indexing tibbles: columns

Indexing columns by name is usually preferred to indexing by position

```{r eval=FALSE}
cities_tbl[1:2] # okay
cities_tbl[c("cities", "population")] # better
```

#### Why?

--

- code is much easier to read

--

- code is more robust against
  - changes in column order
  - mistakes in the code (e.g. typos)

--
  
```{r eval=FALSE}
cities_tbl[c(1,3)] # 3 instead of 2 -> wrong but no error
cities_tbl[c("cities", "popluation")] # typo -> wrong and error
```

--

.content-box-yellow[`r fa("lightbulb")` General rule: Good code produces errors when something unintended or wrong happens]

---
# Tibbles: Select columns with `$`

Select an entire column from a tibble using `$` (this returns a vector instead of a tibble):

```{r}
cities_tbl$cities
```
--

After selecting a column as vector, we can work with the vector as we are used to:

```{r}
cities_tbl$cities[1:3] # first 3 cities
```
--

```{r error=TRUE}
cities_tbl$cities[1,1] # This is wrong now because vector is 1-dimensional
```

---
# Logical indexing

As with vectors, we can use us logical tests to **select rows** from a tibble. 
The basic structure is:<br>

<b>.center[tibble [ .col1[logical indexing vector of length nrow(tibble)], .col2[ cols to select] ]]</b>

Only rows that match `TRUE` in the indexing vector get selected.

--

```{r}
# select all rows for which the population exceeds 15 M
cities_tbl[ cities_tbl$population > 15e6, ]
```

---
# Logical indexing

**What is happening in detail?**

```{r eval=FALSE}
cities_tbl[cities_tbl$population > 15e6, ]#<<
```

--

```{r}
cities_tbl$population # vector with population
```

--

```{r}
cities_tbl$population > 15e6 # logical vector after relational test
```

--

So we actually subset the tibble like this:

```{r, eval=FALSE}
cities_tbl[c(TRUE, FALSE, FALSE, FALSE, FALSE,
             FALSE, FALSE, FALSE, FALSE, FALSE), ]
```

---
# Logical indexing

Some more examples:

```{r}
cities_tbl[cities_tbl$cities != "Istanbul" & cities_tbl$area_km2 > 1000, ] #<<
```

---
# Logical indexing

Some more examples:

```{r eval=FALSE}
cities_tbl[cities_tbl$cities != "Istanbul" & cities_tbl$area_km2 > 1000, ]
cities_tbl[cities_tbl$cities %in% c("Istanbul", "Madrid", "Paris"), ] #<<
```


```{r echo=FALSE}
cities_tbl[cities_tbl$cities %in% c("Istanbul", "Madrid", "Paris"), ]
```

---
# Logical indexing

Some more examples:

```{r eval=FALSE}
cities_tbl[cities_tbl$cities != "Istanbul" & cities_tbl$area_km2 > 1000, ]
cities_tbl[cities_tbl$cities %in% c("Istanbul", "Madrid", "Paris"), ]
cities_tbl[!(cities_tbl$cities %in% c("Istanbul", "Madrid", "Paris")) | #<<
             cities_tbl$area_km2 >= 2000, ] #<<
```


```{r echo=FALSE}
cities_tbl[!(cities_tbl$cities %in% c("Istanbul", "Madrid", "Paris")) | 
             cities_tbl$area_km2 >= 2000, ]
```

---
# Changing values in tibbles

As with vectors, we can use indexing to change specific values in the tibble.

--

**Idea:**<br>
1. Index row and column or the values you want to change
2. Overwrite them using the assignment operator `<-`

--

For example, the population of Madrid changed but we don't know the new population.

--

We can replace the population value from Madrid with NA:

```{r eval = TRUE}
cities_tbl[cities_tbl$cities == "Madrid", "population"] <- NA
```

--

```{r}
cities_tbl[6, ] # row 6 is Madrid
```

---
# Adding new columns

New columns can be added as vectors using the `$` operator. The vectors need to have the same length as the tibble has rows.

--

```{r}
# add a country column
cities_tbl$country <- c(
  "Turkey", "Russia", "UK", "Russia", "Germany", "Spain",
  "Ukraine", "Italy", "Romania", "France"
)
```
```{r echo=FALSE}
cities_tbl
```

---
# Adding new columns

Adding a new column **based on other columns**:

```{r}
cities_tbl$density <- cities_tbl$population / cities_tbl$area_km2
```

```{r echo=FALSE}
cities_tbl
```

---
# Adding new columns

Adding new columns **based on a condition**:

```{r}
cities_tbl$category <- ifelse(cities_tbl$population > 5e6,
                              "very large",
                              "large")
```
```{r echo=FALSE}
cities_tbl
```

---
# Deleting a column

Columns can be deleted, by assigning `NULL`:

```{r}
# delete the new category column
cities_tbl$category <- NULL
cities_tbl
```

---
# Summary I

#### data frames and tibbles

- can be used to represent tables in R
- are pretty similar, however tibbles are slightly conventient and modern
- are **named lists of vectors of the same length**
  - every column is a vector
  - columns have a header which is the name of the vector in the list
  - within one column, values are of same data type
  - every column has the same length
  
#### tibbles

- to use tibbles, install the package once with `install.packages("tibble")`
- put `library(tibble)` at the beginning of your script to load package

---
# Summary II

#### Creating tibbles and data frames

```{r eval=FALSE}
# data frame
data.frame(
  a = 1:3,
  b = c("a", "b", "c"),
  c = c(TRUE, FALSE, FALSE) 
)
# tibble
tibble(
  a = 1:3,
  b = c("a", "b", "c"),
  c = c(TRUE, FALSE, FALSE) 
)
# convert data frame to tibble
as_tibble(df)
```

---
# Summary III

#### Looking at tibble structure

```{r eval=FALSE}
# structure of tibble and data types of columns
str(tbl)
# number of rows
nrow(tbl)
# number of columns
ncol(tbl)
# column headers
names(tbl)
# look at the data in a new window
tibble::view(tbl)
# summary of values from each column
summary(tbl)
```

---
# Summary IV

#### Indexing tibbles and selecting columns

Return result as tibble:

```{r eval=FALSE}
# rows and columns by position
tbl[1:3, c(1, 3)]
tbl[1:3, ] # all columns
tbl[, 3] # column 3, all rows
tbl[3] # same as above

# columns by name
tbl[, c("colA", "colB")]
tbl[c("colA", "colB")]
```

Return result as vector:

```{r eval=FALSE}
tbl$colA # select colA  
```

---
# Summary V

#### Logical indexing to select rows

- Index tibbles with a vector of the same length
- Use
  - logical and relational operators
  - `%in%`

```{r eval=FALSE}
tbl[tbl$colA == 5, ] # only rows where colA is 5 (all columns)
tbl[tbl$colA >= 10, ]
tbl[tbl$colB %in% c("hello", "cat", "apple"), ] # only rows where colB is "hello", "cat" or "apple"
tbl[tbl$colB == "hello" | tbl$colB == "cat" | tbl$colB == "apple", ] # same as above
```

#### Logical indexing to select columns

```{r eval=FALSE}
select_cols <- c("colA", "colB", "colC")
tbl[names(tbl) %in% select_cols]
tbl[c("colA", "colB", "colC")] # same as above
```

---
# Summary VI

#### Add and remove columns

```{r eval=FALSE}
tbl$new_col <- c(1, 2, 3)
tbl$new_col <- tbl$colA / tbl$colB # new column based on other columns
tbl$new_col <- NULL # remove new_col
```

---
# Resources

- [Differences between tibbles and data frames](https://adv-r.hadley.nz/vectors-chap.html#tibble)
